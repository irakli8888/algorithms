package boyer_moor;

/**
 * Упрощенный алгоритм Бойера-Мура
 * <br>Сначала строится таблица смещений для каждого символа. Затем исходная строка и шаблон совмещаются
 * по началу, сравнение ведется по последнему символу. Если последние символы совпадают, то сравнение
 * идет по предпоследнему символу и так далее. Если же символы не совпали, то шаблон смещается вправо,
 * на число позиций взятое из таблицы смещений для символа из исходной строки, и тогда снова сравниваются
 * последние символы исходной строки и шаблона. И так далее, пока не шаблон полностью не совпадет с подстрокой
 * исходной строки, или не будет достигнут конец строки.
 */
public class App {

    public static void main(String[] args) {
        System.out.println(search("sricngrongstring", "ring"));
    }


    public static int search(String text, String mask) {
        int[] shift = createShift(mask);
        int t = 0;//указатель на индекс элемента из родительской строки
        while (t <= text.length() - mask.length())
        {
            int m = 0;//указатель на индекс элемента из искомой подстроки

            while (m < mask.length() && text.toCharArray()[t + m] == mask.toCharArray()[m]) {
                m++;
            }
            //отдаем результат, как только счетчик доходит до длины искомой подстроки
            if(m == mask.length()){
                return t;
            }
            t += shift[text.toCharArray()[t + mask.length() - 1]];
        }
        return -1;
    }

    /**
     * Составление таблицы смещения
     *<br> Таблица смещений строится по принципу «пропускать столько символов, сколько возможно,
     * но не более этого». Например, если на каком-то шаге алгоритма последние символы не совпали,
     * и символ, находящийся в исходной строке не присутствует в шаблоне вообще, то понятно,
     * что можно сдвинуться вправо на полную длину шаблона, без каких-либо опасений. В общем
     * случае, каждому символу ставится в соответствие величина, равная разности длины шаблона
     * и порядкового номера символа (если символ повторяется, то берется самое правое вхождение).
     * Ясно, что эта величина будет в точности равна порядковому номеру символа, если считать от
     * конца строки, что и дает возможность смещаться вправо на максимально возможное число позиций.
     * @param mask искомая подстрока
     * @return таблица смещения
     */
    public static int[] createShift(String mask){
        int [] shift = new int[128];

        for (int i = 0; i < shift.length; i++) {
            shift[i] = mask.length();
        }

        for (int i = 0; i < mask.length() - 1; i++) {
            shift[mask.toCharArray()[i]] = mask.length() - i - 1;
        }
        return shift;
    }
}
